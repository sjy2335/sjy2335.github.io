---
title: JS OOP 학습 정리
date: 2024-07-22 00:00:00 +09:00
categories: [Dev, CS]
tags: [TIL, OOP, Polymorphism, Class, JS]
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [Prototype](#prototype)
- [4 Pillars of OOP](#4-pillars-of-oop)
- [SOLID](#solid)

<!-- /code_chunk_output -->

### Prototype

_prototype: 원형(原型), 앞서 제작하는 시제품이자 표준, ..._
JS하면 빠질 수 없는 것이 프로토타입(Prototype)입니다. 그러나 ES6로 넘어온 뒤에 JS를 학습했기에 프로토타입에 익숙지 않아 학습해 보았습니다.

- 프로토타입 생성

  ```js
  // 생성 방법 1. Object.create()
  const personPrototype = {
    greet() {
      console.log("hello!");
    }
  };
  ```

  ```js
  const sj = Object.create(personPrototype);
  sj.greet(); // hello!

  // 생성 방법 2. 생성자 함수 이용
  // js의 모든 함수는 prototype 속성을 가지며, 생성자로 불리면 이 속성이 새롭게 생성된 객체의 프로토타입이 됩니다.
  const personPrototype = {
    greet() {
      console.log(`hello, my name is ${this.name}!`);
    }
  };
  function Person(name) {
    this.name = name;
  }

  Object.assign(Person.prototype, personPrototype);
  const yj = new Person("Yoon");
  yj.greet(); // hello, my name is Yoon!
  ```

- `Object.hasOwn(객체, 메소드 혹은 변수)` 프로토타입으로 정의된 메소드는 hasOwn에서 false를 반환하여 구분됩니다.

- 프로토타입은 디자인 패턴 중 하나입니다. 객체를 효율적으로 생성하는 방법으로, 비용이 큰 객체의 생성을 회피합니다.
- 위 예시에서와 같이 프로토타입으로 객체를 생성하면 프로토타입의 메모리 공간을 공유하여 자원을 아낄 수 있습니다.

- 자바스크립트는 모든 객체를 생성할 때 프로토타입을 사용하며, 이는 객체를 생성하기만 해도 프로토타입이 적용된다는 뜻입니다.

- 자바스크립트에서 객체를 만드는 생성자 자체는 함수입니다.

### 4 Pillars of OOP

- Abstraction
- Encapsulation
- Inheritance
- Polymorphism

### SOLID

**SRP (Single Responsibility Principle) 단일 책임 원칙**

- 하나의 클래스는 하나의 책임만 가져야 한다는 뜻입니다.
- 클래스를 변경하는 이유는 단 하나여야 합니다.

  - 변경이 있을 때 파급 효과가 적어야 합니다.
  - 이를 지키지 않으면, 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향을 미칠 수 있습니다.

- 이때, 책임이란 기능이나 역할과 같이 생각하면 됩니다.
- 책임이 여러개면 클래스와 내부 함수끼리 결합을 가진 확률이 높아지고, 이는 좋지 않은 코드를 낳습니다.

**OCP (Open-Closed Principle) 개방-폐쇄 원칙**

- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 합니다.
- 즉, 기존의 코드를 변경하지 않고 기능을 수정, 추가할 수 있도록 설계해야합니다.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현해야 합니다.

- 상속(다형성)과 추상화(인터페이스)를 활용합니다.
- TypeScript...?

**LSP (Liskov Substitution Principle) 리스코프 치환 원칙**

- 하위 타입 객체는 상위 타입 객체에서 가능한 행위를 수행할 수 있어야 한다.
  - 즉, 상위 타입 객체를 하위 타입 객체로 대체하여도 정상적으로 동작해야 한다.

**ISP (Interface Segregation Principle) 인터페이스 분리 원칙**

- 클라이언트는 자신이 사용하는 메소드에만 의존해야 한다.

**DIP (Dependency Inversion Principle) 의존 역전 원칙**

- "추상회에 의존해야지, 구체화에 의존하면 안된다."
- 변하기 어려운 추상적인 것에 의존해야 한다는 것입니다.
  - 즉, 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻입니다.
- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안됩니다.
  - 이상적인 형태는 저수준 모듈이 변경되어도 고수준 모듈은 변경이 필요없는 것입니다.
